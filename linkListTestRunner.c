#include <stdio.h>
typedef void TestFn(void);
typedef struct{
	char* name; 
	TestFn* fn;
} Test;

//code to be updated starts
TestFn setup,teardown,fixtureSetup,fixtureTearDown,test_create_node_creates_a_node_that_returns_the_address_of_the_node_for_int_type,test_create_node_create_a_new_node_that_intializes_data_of_int_type,test_create_node_creates_a_new_node_that_initializes_next_to_null_of_int_type,test_createList_creates_an_empty_link_list,test_add_to_list_return_1_for_adding_a_node_to_a_list,test_add_to_list_should_increments_count_to_1_if_node_added_to_Linked_List,test_add_to_list_should_set_head_as_address_of_first_node,test_add_to_list_should_set_tail_as_address_of_last_node,test_get_first_element_should_return_head_of_given_linked_list,test_get_last_element_should_return_tail_of_given_linked_list_if_head_and_tail_are_same,test_get_last_element_should_return_tail_of_given_linked_list_if_head_and_tail_are_different,test_traverse_should_increment_all_list_elements_by_1_with_increment_function_in_INT,test_traverse_should_convert_all_list_chars_in_upperCase_with_myToUpper_function_in_CHAR,test_traverse_should_convert_all_list_float_in_their_Ceil_value_with_myCeil_function_in_FLOAT,test_traverse_should_convert_all_list_double_in_their_floor_value_with_myFloor_function_in_DOUBLE,test_traverse_should_convert_string_to_upperCase_with_stringToUpper_function_for_STRING,test_getElementAt_should_return_NULL_if_given_index_is_not_exist_in_list_of_INT,test_getElementAt_should_return_element_on_the_given_index_in_list_of_CHAR,test_indexOf_should_return_minus_1_if_given_element_is_not_found_in_list,test_indexOf_should_return_index_of_given_element_if_found_in_list_of_INT,test_indexOf_should_return_index_of_given_element_if_found_in_list_of_CHAR,test_deleteElementAt_deletes_the_node_and_returns_deleted_data_reference,test_deleteElementAt_deletes_the_head_and_head_changes_to_2nd_node,test_deleteElementAt_deletes_the_tail_and_tail_changes_to_last_2nd_node,test_asArray_copies_list_to_array_and_returns_array_length,test_filter_returns_the_filtered_linked_list,test_filter_returns_the_filtered_linked_list_with_the_new_head_and_tail;
Test test[] = {"test_create_node_creates_a_node_that_returns_the_address_of_the_node_for_int_type",test_create_node_creates_a_node_that_returns_the_address_of_the_node_for_int_type,"test_create_node_create_a_new_node_that_intializes_data_of_int_type",test_create_node_create_a_new_node_that_intializes_data_of_int_type,"test_create_node_creates_a_new_node_that_initializes_next_to_null_of_int_type",test_create_node_creates_a_new_node_that_initializes_next_to_null_of_int_type,"test_createList_creates_an_empty_link_list",test_createList_creates_an_empty_link_list,"test_add_to_list_return_1_for_adding_a_node_to_a_list",test_add_to_list_return_1_for_adding_a_node_to_a_list,"test_add_to_list_should_increments_count_to_1_if_node_added_to_Linked_List",test_add_to_list_should_increments_count_to_1_if_node_added_to_Linked_List,"test_add_to_list_should_set_head_as_address_of_first_node",test_add_to_list_should_set_head_as_address_of_first_node,"test_add_to_list_should_set_tail_as_address_of_last_node",test_add_to_list_should_set_tail_as_address_of_last_node,"test_get_first_element_should_return_head_of_given_linked_list",test_get_first_element_should_return_head_of_given_linked_list,"test_get_last_element_should_return_tail_of_given_linked_list_if_head_and_tail_are_same",test_get_last_element_should_return_tail_of_given_linked_list_if_head_and_tail_are_same,"test_get_last_element_should_return_tail_of_given_linked_list_if_head_and_tail_are_different",test_get_last_element_should_return_tail_of_given_linked_list_if_head_and_tail_are_different,"test_traverse_should_increment_all_list_elements_by_1_with_increment_function_in_INT",test_traverse_should_increment_all_list_elements_by_1_with_increment_function_in_INT,"test_traverse_should_convert_all_list_chars_in_upperCase_with_myToUpper_function_in_CHAR",test_traverse_should_convert_all_list_chars_in_upperCase_with_myToUpper_function_in_CHAR,"test_traverse_should_convert_all_list_float_in_their_Ceil_value_with_myCeil_function_in_FLOAT",test_traverse_should_convert_all_list_float_in_their_Ceil_value_with_myCeil_function_in_FLOAT,"test_traverse_should_convert_all_list_double_in_their_floor_value_with_myFloor_function_in_DOUBLE",test_traverse_should_convert_all_list_double_in_their_floor_value_with_myFloor_function_in_DOUBLE,"test_traverse_should_convert_string_to_upperCase_with_stringToUpper_function_for_STRING",test_traverse_should_convert_string_to_upperCase_with_stringToUpper_function_for_STRING,"test_getElementAt_should_return_NULL_if_given_index_is_not_exist_in_list_of_INT",test_getElementAt_should_return_NULL_if_given_index_is_not_exist_in_list_of_INT,"test_getElementAt_should_return_element_on_the_given_index_in_list_of_CHAR",test_getElementAt_should_return_element_on_the_given_index_in_list_of_CHAR,"test_indexOf_should_return_minus_1_if_given_element_is_not_found_in_list",test_indexOf_should_return_minus_1_if_given_element_is_not_found_in_list,"test_indexOf_should_return_index_of_given_element_if_found_in_list_of_INT",test_indexOf_should_return_index_of_given_element_if_found_in_list_of_INT,"test_indexOf_should_return_index_of_given_element_if_found_in_list_of_CHAR",test_indexOf_should_return_index_of_given_element_if_found_in_list_of_CHAR,"test_deleteElementAt_deletes_the_node_and_returns_deleted_data_reference",test_deleteElementAt_deletes_the_node_and_returns_deleted_data_reference,"test_deleteElementAt_deletes_the_head_and_head_changes_to_2nd_node",test_deleteElementAt_deletes_the_head_and_head_changes_to_2nd_node,"test_deleteElementAt_deletes_the_tail_and_tail_changes_to_last_2nd_node",test_deleteElementAt_deletes_the_tail_and_tail_changes_to_last_2nd_node,"test_asArray_copies_list_to_array_and_returns_array_length",test_asArray_copies_list_to_array_and_returns_array_length,"test_filter_returns_the_filtered_linked_list",test_filter_returns_the_filtered_linked_list,"test_filter_returns_the_filtered_linked_list_with_the_new_head_and_tail",test_filter_returns_the_filtered_linked_list_with_the_new_head_and_tail};
char testFileName[] = {"linkListTest.c"};
void _setup(){/*CALL_SETUP*/}
void _teardown(){/*CALL_TEARDOWN*/}
void fixtureSetup(){}
void fixtureTearDown(){}
//code to be updated ends

int testCount;
int passCount;
int currentTestFailed;

int assert_expr(int expr, const char* fileName, int lineNumber, const char* expression){
	if(expr) return 0;
	currentTestFailed = 1;
	printf("\t %s : failed at %s:%d\n",expression, fileName,lineNumber);
	return 1;
}
int assert_equal(int val1, int val2, const char* fileName, int lineNumber,const char* expr1,const char* expr2){
	if(val1 == val2) return 0;
	currentTestFailed = 1;
	printf("\t %d == %d: failed in assertEqual(%s,%s) at %s:%d\n",val1,val2,expr1,expr2, fileName,lineNumber);
	return 1;
}

void runTest(char* name, TestFn test){
	testCount++,currentTestFailed=0;
	printf("**  %s\n",name);
	_setup();
		test();
	_teardown();
	if(!currentTestFailed) passCount++;	
}
int main(int argc, char const *argv[]){		
	int i,total = sizeof(test)/sizeof(Test);	
	fixtureSetup();
	testCount=0,passCount=0;
	printf("**------ %s ------\n",testFileName);
	for (i = 0; i < total; ++i)
		runTest(test[i].name,test[i].fn);	
	printf("** Ran %d tests passed %d failed %d\n",testCount,passCount,testCount-passCount);
	fixtureTearDown();	
	return 0;
}